/ * Hak Cipta (C) Federico Zivolo 2019 Didistribusikan di bawah Lisensi MIT (persyaratan lisensi ada di http://opensource.org/licenses/MIT). * / (function (e, t) {'object' == typeof ekspor && 'undefined'! = typeof module? module.exports = t (): 'function' == typeof define && define.amd? define (t): e. Popper = t ()}) (this, function () {'use strict'; function e (e) {return e && '[object function]' === {}. ToString.call (e)} fungsi t (e , t) {if (1! == e.nodeType) return []; var o = e.ownerDocument.defaultView, n = o.getComputedStyle (e, null); mengembalikan t? n [t]: n} fungsi o (e) {return'HTML '=== e.nodeName? e: e.parentNode || e.host} berfungsi n (e) {if (! e) mengembalikan document.body; switch (e.nodeName) {case 'HTML': case'BODY ': return e.ownerDocument.body; case' # document ': return e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; return /(auto|scroll|overlay)/.test(r+s+p)?e:n(o(e)) ringkasfungsi r (e) {return 11 === e? pe: 10 === e? se: pe || se} fungsi p (e) {if (! e) mengembalikan dokumen.documentElement; untuk (var o = r (10)? document.body: null, n = e.offsetParent || null; n === o && e.nextElementSibling;) n = (e = e.nextElementSibling) .offsetParent; var i = n && n.nodeName; kembalikan i && 'BODY'! == i && 'HTML'! == i? -1! == ['TH', 'TD', 'TABLE']. indexOf (n.nodeName) && 'static '=== t (n,' posisi ')? p (n): n: e? e.ownerDocument.documentElement: fungsi document.documentElement} s (e) {var t = e.nodeName; return'BODY'! == t && ('HTML' === t || p (e.firstElementChild) === e)} fungsi d (e) {return null === e.parentNode? e: d (e.parentNode)} fungsi a (e, t) {if (! e ||! e.nodeType ||! t ||! t.nodeType) mengembalikan document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, n = o? e: t, i = o? t: e, r = document.createRange (); r.setStart (n, 0), r.setEnd (i, 0); var l = r.commonAncestorContainer; if (e! == l && t! == l || n.contains (i)) return s (l)? l: p (l); var f = d (e); return f.host?a ( f.host, t): a (e, d (t) .host)} fungsi l (e) {var t = 1 <arguments.length && void 0! == argumen [1]? argumen [1]: 'top' , o = 'top' === t? 'scrollTop': 'scrollLeft', n = e.nodeName; if ('BODY' === n || 'HTML' === n) {var i = e. ownerDocument.documentElement, r = e.ownerDocument.scrollingElement || i; return r [o]} mengembalikan e [o]} fungsi f (e, t) {var o = 2 <arguments.length && void 0! == argumen [2] ] && argumen [2], n = l (t, 'atas'), i = l (t, 'kiri'), r = o? -1: 1; return e.top + = n * r, e.bottom + = n * r, e.left + = i * r, e.right + = i * r, e} berfungsi m (e, t) {var o = 'x' === t? 'Kiri': 'Atas', n = 'Kiri' == o? 'Kanan': 'Bawah'; kembalikan parseFloat (e ['batas' + o + 'Lebar'], 10) + parseFloat (e ['border '+ n +' Width '], 10)} fungsi h (e, t, o, n) {return ee (t [' offset '+ e], t [' scroll '+ e], o [' client ' + e], o ['offset' + e], o ['scroll' + e], r (10)? parseInt (o ['offset' + e]) + parseInt (n ['margin' + ('Tinggi '=== e?' Top ':' Kiri ')]) + parseInt (n [' margin '+ (' Tinggi '=== e?' Bawah ':' Kanan ')]): 0)} fungsi c (e) {var t = e.body, o = e.documentElement, n = r (10) && getComputedStyle (o); return {tinggi: h ('Tinggi', t, o, n), lebar: h (' Lebar ', t, o, n)}} fungsi g (e) {return fe ({}, e, {kanan: e.left + e.width, bawah: e.top + e.height})} berfungsi u (e) {var o = {}; coba {if (r (10)) {o = e.getBoundingClientRect (); var n = l (e, 'top'), i = l (e, 'kiri') ; o.top + = n, o.left + = i, o.bottom + = n, o.right + = i} selain itu o = e.getBoundingClientRect ()} catch (t) {} var p = {kiri: o.left, top: o.top, lebar: o.right-o.kiri, tinggi: o.bottom-o.top}, s = 'HTML' === e.nodeName? c (e.ownerDocument): {}, d = s.width || e.clientWidth || p.right -p.left, a = s.height || e.clientHeight || p.bottom-p.top, f = e.offsetWidth-d, h = e.offsetHeight-a; if (f || h) {var u = t (e); f- = m (u, 'x'), h- = m (u, 'y'), p.width- = f, p.height- = h} mengembalikan g (p) } fungsi b (e, o) {var i = 2 <arguments.length && void 0! == argumen [2] && argumen [2], p = r (10), s = 'HTML' === o.nodeName, d = u (e), a = u (o), l = n (e), m = t (o), h = parseFloat (m.borderTopWidth, 10), c = parseFloat (m.borderLeftWidth, 10); i && s && (a.top = ee (a.top, 0), a.left = ee (a.left, 0)); var b = g ({atas: d.top-a.top-h, kiri: d. left-a.left-c, lebar: d.width, tinggi: d.height}); if (b.marginTop = 0, b.marginLeft = 0,! p&&s) {var w = parseFloat (m.marginTop, 10 ), y = parseFloat (m.marginLeft, 10); b.top- = hw, b.bottom- = hw, b.left- = cy, b.right- = cy, b.marginTop = w, b.marginLeft = y} return (p&&! i? o.contains (l): o === l && 'BODY'! == l.nodeName) && (b = f (b, o)), b} fungsi w (e ) {var t = 1 <arguments.length && void 0! == argumen [1] && argumen [1], o = e.ownerDocument.documentElement, n = b (e, o), i = ee (o.clientWidth, window. innerWidth || 0), r = ee (o.clientHeight, window.innerHeight || 0), p = t? 0: l (o), s = t? 0: l (o, 'kiri'), d = {top: pn.top + n.marginTop, kiri: sn.left + n.marginLeft, lebar: i, tinggi: r}; mengembalikan g (d)} fungsi y (e) {var n = e.nodeName; jika ('BODY' === n || 'HTML' === n) kembali! 1; if ('fix' === t (e, 'posisi')) kembali! 0; var i = o (e) ; return !! i && y (i)} berfungsi E (e) {if (! e ||! e.parentElement || r ()) mengembalikan document.documentElement; untuk (var o = e.parentElement; o && 'none' = == t (o, 'transform');) o = o.parentElement; mengembalikan o || document.documentElement} fungsi v (e, t, i,r) {var p = 4 <arguments.length && void 0! == argumen [4] && argumen [4], s = {atas: 0, kiri: 0}, d = p? E (e): a (e, t ); if ('viewport' === r) s = w (d, p); else {var l; 'scrollParent' === r? (l = n (o (t)), 'BODY' == = l.nodeName && (l = e.ownerDocument.documentElement)): 'window' === r? l = e.ownerDocument.documentElement: l = r; var f = b (l, d, p); if (' HTML '=== l.nodeName &&! Y (d)) {var m = c (e.ownerDocument), h = m.tinggi, g = m.width; s.top + = f.top-f.marginTop, s .bottom = h + f.top, s.left + = f.left-f.marginLeft, s.right = g + f.left} else s = f} i = i || 0; var u = 'number' = = typeof i; return s.left + = u? i: i.left || 0, s.top + = u? i: i.top || 0, s.right- = u? i: i.right || 0 , s.bottom- = u? i: i.bottom || 0, s} fungsi x (e) {var t = e.width, o = e.height; return t * o} fungsi O (e, t, o, n, i) {var r = 5 <arguments.length && void 0! == argumen [5]? argumen [5]: 0; if (-1 === e.indexOf ('auto')) mengembalikan e; var p = v (o, n, r, i), s = {atas: {lebar: p.width, tinggi: t.top-p.top}, kanan: {width: p.right -t.right, tinggi: p.height}, bawah: {lebar: p.width, tinggi: p.bottom-t.bottom}, kiri: {width: t.left-p.left, tinggi: p.height }}, d = Object.keys (s) .map (fungsi (e) {return fe ({key: e}, s [e], {area: x (s [e])})}). sort ( function (e, t) {return t.area-e.area}), a = d.filter (fungsi (e) {var t = e.width, n = e.height; return t> = o.clientWidth && n> = o.clientHeight}), l = 0 <a.length? a [0] .key: d [0] .key, f = e.split ('-') [1]; return l + (f? '- '+ f:' ')} fungsi L (e, t, o) {var n = 3 <arguments.length && void 0! == argumen [3]? argumen [3]: null, i = n? E (t) : a (t, o); mengembalikan b (o, i, n)} fungsi S (e) {var t = e.ownerDocument.defaultView, o = t.getComputedStyle (e), n = parseFloat (o.marginTop | | 0) + parseFloat (o.marginBottom || 0), i = parseFloat (o.marginLeft || 0) + parseFloat (o.marginRight || 0), r = {width: e.offsetWidth + i, tinggi: e.offsetHeight + n}; return r} fungsi T (e) {var t = {kiri: 'kanan', kanan: 'kiri', kanan: 'kiri', bawah: 'atas', atas: 'bawah'} ; return e.replace (/ kiri | kanan | bawah | atas / g, fungsi (e) {return t [e]})} fungsi D (e, t, o) {o = o.split ('-') [0]; var n = S (e), i = {width: n.width, tinggi: n.height}, r = -1! == ['kanan', 'kiri']. IndexOf (o), p = r? 'atas': 'kiri', s = r? 'kiri': 'atas', d = r? 'tinggi': 'lebar', a = r? 'lebar': 'tinggi'; kembali i [p] = t [p] + t [d] / 2-n [d] / 2, i [s] = o === s? t [s] -n [a]: t [T (s) ], i} fungsi C (e, t) {return Array.prototype.find? e.find (t): e.filter (t) [0]} fungsi N (e, t, o) {if (Array. prototype.findIndex) return e.findIndex (fungsi (e) {return e [t] === o}); var n = C (e, fungsi (e) {return e [t] === o}); return e.indexOf (n)} fungsi P (t, o, n) {var i = void 0 === n? t: t.slice (0, N (t, 'name', n));mengembalikan i.forEach (fungsi (t) {t ['fungsi'] && console.warn ('`modifier.function` tidak digunakan lagi, gunakan` modifier.fn`!'); var n = t ['function'] || t.fn; t.enabled && e (n) && (o.offsets.popper = g (o.offsets.popper), o.offsets.reference = g (o.offsets.reference), o = n (o, t) )}), o} fungsi k () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {}, atribut: {}, flipped:! 1, offset : {}}; e.offsets.reference = L (this.state, this.popper, this.reference, this.options.positionFixed), e.placement = O (this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e.placement, e.positionFixed = this.options.positionFixed, e.offsets .popper = D (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = this.options.positionFixed? 'fixed': 'absolute', e = P (this.modifiers, e), this.state.isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options. onCreate (e))}} fungsi W (e, t) {return e.some (fungsi (e) {var o = e.name, n = e.enabled; return n && o === t})} fungsi H (fungsi e) {untuk (var t = [! 1, 'ms', 'Webkit', 'Moz', 'O'], o = e.charAt (0) .toUpperCase () + e.slice (1), n = 0; n <t.length; n ++) {var i = t [n], r = i? '' + I + o: e; if ('undefined'! = Typeof document.body.style [r]) return r} return null} fungsi B () {return this.state.isDestroyed =! 0, W (this.modifiers, 'applyStyle') && (this.popper.removeAttribute ('x-placement'), this.popper. style.position = '', this.popper.style.top = '', this.popper.style.left = '', this.popper.style.right = '', this.popper.style.bottom = '' , this.popper.style.willChange = '', this.popper.style [H ('transform')] = ''), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), fungsi} ini A (e) {var t = e.ownerDocument; mengembalikan t? t.defaultView: window} fungsi M (e, t, o, i) {var r = 'BODY' === e.nodeName, p = r? e .ownerDocument.defaultView: e; p.addEventListener (t, o, {pasif:! 0}), r || M (n (p.parentNode), fungsi t, o, i), i.push (p)} F (e, t, o, i) {o.updateBound = i, A (e) .addEventListener ('resize', o.updateBound, {pasif:! 0}); var r = n (e); return M (r, 'scroll', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled =! 0, o} function I () {this.state.eventsEnabled || (this.state = F ( this.reference, this.options, this.state, this.scheduleUpdate))} fungsi R (e, t) {return A (e) .removeEventListener ('ubah ukuran', t.updateBound), t.scrollParents.forEach (fungsi (e) {e.removeEventListener ('scroll', t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} function U () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate), this.state = R (this.reference, this.state))} function Y (e) {return ''! == e &&! isNaN ( parseFloat (e)) && isFinite (e)} fungsi j (e, t) {Object.keys (t) .forEach (fungsi (o) {var n = ''; - 1! == ['width', 'height ',' atas ',' kanan ',' bawah ',' kiri ']. indexOf (o) && Y (t [o]) && (n =' px '), e.style [o] = t [o] + n})} fungsi V (e, t) {Object.keys (t) .forEach (fungsi (o) {var n = t [o];! 1 === n? e.removeAttribute (o): e .setAttribute (o, t [o])})} fungsi q (e, t) {var o = e.offsets, n = o.popper, i = o.referensi, r = $, p = fungsi (e) {return e}, s = r (i.width), d = r (n.width), a = -1! == ['kiri ',' kanan ']. indexOf (e.placement), l = -1! == e.placement.indexOf (' - '), f = t? a || l || s% 2 == d% 2? R: Z: p, m = t? R: p; return {kiri: f (1 == s% 2 && 1 == d% 2 &&! L && t? N.left-1: n.left), atas: m (n.top), bawah: m (n.bottom), kanan: f (n.right)}} fungsi K (e, t, o) {var n = C (e, fungsi (e) {var o = e.name; return o === t}), i = !! n && e.some (fungsi (e) {return e.name === o && e.enabled && e.order <n.order}); if (! i) {var r = '`' + t + '`'; console.warn ('`' + o + '`' + 'pengubah diperlukan oleh pengubah' + r + 'untuk bekerja, pastikan untuk memasukkannya sebelum' + r + '!')} return i} berfungsi z (e) {return'end '=== e?' start ':' start '=== e?' end ': e} fungsi G (e) {var t = 1 <arguments.length && void 0! == argumen [1] && argumen [1], o = ce.indexOf (e), n = ce.slice (o + 1) .concat (ce.slice (0,o)); mengembalikan t? n.balik (): n} fungsi _ (e, t, o, n) {var i = e.match (/ ((?: \ - | \ +)? \ d * \ .? \ d *) (. *) /), r = + i [1], p = i [2]; if (! r) mengembalikan e; jika (0 === p.indexOf ('%') ) {var s; switch (p) {case '% p': s = o; break; case '%': case '% r': default: s = n;} var d = g (s); return d [t] / 100 * r} if ('vh' === p || 'vw' === p) {var; kembalikan a = 'vh' === p? ee (document.documentElement.clientHeight, window.innerHeight || 0): ee (document.documentElement.clientWidth, window.innerWidth || 0), a / 100 * r} mengembalikan r} fungsi X (e, t, o, n) {var i = [0 , 0], r = -1! == ['kanan', 'kiri']. IndexOf (n), p = e.split (/ (\ + | \ -) ​​/). Map (fungsi (e) { return e.trim ()}), s = p.indexOf (C (p, function (e) {return-1! == e.search (/, | \ s /)})); p [s] && -1 === p [s] .indexOf (',') && console.warn ('Offset yang dipisahkan oleh spasi putih tidak digunakan lagi, gunakan koma (,) sebagai gantinya.'); Var d = / \ s * , \ s * | \ s + /,a = -1 === s? [p]: [p.slice (0, s) .concat ([p [s] .split (d) [0]]), [p [s] .split (d ) [1]]. Concat (p.slice (s + 1))]; mengembalikan a = a.map (fungsi (e, n) {var i = (1 === n?! R: r)? ' tinggi ':' lebar ', p =! 1; return e.reduce (fungsi (e, t) {return' '=== e [e.length-1] && - 1! == [' + ',' - ']. indexOf (t)? (e [e.length-1] = t, p =! 0, e): p? (e [e.length-1] + = t, p =! 1, e ): e.concat (t)}, []). map (fungsi (e) {return _ (e, i, t, o)})}), a.forEach (fungsi (e, t) {e. forEach (fungsi (o, n) {Y (o) && (i [t] + = o * ('-' === e [n-1]? - 1: 1))})}), i} fungsi J (e, t) {var o, n = t.offset, i = e.placement, r = e.offsets, p = r.popper, s = r.reference, d = i.split ('-' ) [0]; return o = Y (+ n)? [+ N, 0]: X (n, p, s, d), 'kiri' === d? (P.top + = o [0], p.left- = o [1]): 'benar' === d? (p.top + = o [0], p.left + = o [1]): 'top' === d? (hal. kiri + = o [0], p.top- = o [1]): 'bawah' === d && (p.left + = o [0], p.top + = o [1]), e.popper = p ,e} untuk (var Q = Math.min, Z = Math.floor, $ = Math.round, ee = Math.max, te = 'tidak terdefinisi'! = jenis jendela && 'tidak terdefinisi'! = jenis dokumen, oe = [' Edge ',' Trident ',' Firefox '], ne = 0, yaitu = 0; yaitu <oe.length; yaitu + = 1) if (te && 0 <= navigator.userAgent.indexOf (oe [ie])) {ne = 1; break} var i = te && window.Promise, re = i? Function (e) {var t =! 1; return function () {t || (t =! 0, window.Promise.resolve (). Lalu ( function () {t =! 1, e ()}))}}: function (e) {var t =! 1; mengembalikan fungsi () {t || (t =! 0, setTimeout (function () {t =! 1, e ()}, ne))}}, pe = te && !! (window.MSInputMethodContext && document.documentMode), se = te && / MSIE 10 / .test (navigator.userAgent), de = fungsi (e, t ) {if (! (e instanceof)) melempar TypeError baru ('Tidak dapat memanggil kelas sebagai fungsi')}, ae = function () {function e (e, t) {for (var o, n = 0; n <t.length; n ++) o = t [n], o.enumerable = o.enumerable ||! 1,o.configurable =! 0, 'value'in o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} fungsi pengembalian (t, o, n) {return o && e (t.prototype , o), n && e (t, n), t}} (), le = function (e, t, o) {return t in e? Object.defineProperty (e, t, {value: o, enumerable:! 0 , dapat dikonfigurasi:! 0, dapat ditulis:! 0}): e [t] = o, e}, fe = Object.assign || fungsi (e) {for (var t, o = 1; o <arguments.length; o ++) untuk (var n in t = argumen [o], t) Object.prototype.hasOwnProperty.call (t, n) && (e [n] = t [n]); return e}, me = te && / Firefox /i.test(navigator.userAgent),he=['auto-start','auto','auto-end','top-start','top' ,'top-end','right-start ' , 'kanan', 'ujung kanan', 'ujung bawah', 'bawah', 'awal-bawah', 'kiri-akhir', 'kiri', 'kiri-mulai'], ce = he.slice ( 3), ge = {FLIP: 'flip', CLOCKWISE:'searah jarum jam', COUNTERCLOCKWISE: 'berlawanan arah jarum jam'}, ue = function () {function t (o, n) {var i = this, r = 2 <arguments.length && void 0! == argumen [2]? argumen [2] : {}; de (ini, t), this.scheduleUpdate = function () {return requestAnimationFrame (i.update)}, this.update = re (this.update.bind (this)), this.options = fe ( {}, t.Defaults, r), this.state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery? o [0]: o, this.popper = n && n.jquery? n [0]: n, this.options.modifiers = {}, object.keys (fe ({}, t.Defaults.modifiers, r.modifiers)). forEach (fungsi (e) {i. options.modifiers [e] = fe ({}, t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [e]: {})}), this.modifiers = Object.keys ( this.options.modifiers) .map (function (e) {return fe ({name: e}, i.options.modifiers [e])}). sort (fungsi (e, t) {return e.order-t .order}), this.modifiers.forEach (fungsi (t) {t.diaktifkan && e (t.onLoad) && t.onLoad (i.reference, i.popper, i.options, t, i.state)}), this.update (); var p = this.options.eventsEnabled; p && this.enableEventListeners ( ), this.state.eventsEnabled = p} return ae (t, [{key: 'update', value: function () {return k.call (this)}}, {key: 'destroy', value: function ( ) {return B.call (this)}}, {key: 'enableEventListeners', nilai: function () {return I.call (this)}}, {key: 'disableEventListeners', value: function () {return U .call (this)}}]), t} (); return ue.Utils = ('undefined' == typeof window? global: window) .PopperUtils, ue.placements = he, ue.Defaults {{penempatan: ' bawah ', positionFixed:! 1, eventsEnabled:! 0, hapus OnDestroy:! 1, onCreate: function () {}, onUpdate: function () {}, pengubah: {shift: {order: 100, diaktifkan:! 0, fn : function (e) {var t = e.placement, o = t.split ('-') [0], n = t.split ('-') [1];jika (n) {var i = e.offsets, r = i.reference, p = i.popper, s = -1! == ['bottom', 'top']. indexOf (o), d = s? 'kiri': 'atas', a = s? 'lebar': 'tinggi', l = {mulai: le ({}, d, r [d]), akhir: le ({}, d, r [d ] + r [a] -p [a])}; e.offsets.popper = fe ({}, p, l [n])} return e}}, offset: {order: 200, diaktifkan:! 0, fn: J, offset: 0}, preventOverflow: {order: 300, diaktifkan:! 0, fn: function (e, t) {var o = t.batasanElement || p (e.instance.popper); e.instance .referensi === o && (o = p (o)); var n = H ('transform'), i = e.instance.popper.style, r = i.top, s = i.left, d = i [n]; i.top = '', i.left = '', i [n] = ''; var a = v (e.instance.popper, e.instance.reference, t.padding, o, e .positionFixed); i.top = r, i.left = s, i [n] = d, t.boundaries = a; var l = t.priority, f = e.offsets.popper, m = {primer: fungsi (e) {var o = f [e]; return f [e] <a [e] &&! t.escapeWithReference && (o = ee (f [e], a [e])), le ({}, e ,Hai)},sekunder: function (e) {var o = 'kanan' === e? 'kiri': 'atas', n = f [o]; mengembalikan f [e]> a [e] &&! t.escapeWithReference && (n = Q (f [o], a [e] - ('right' === e? F.width: f.height))), le ({}, o, n)}}; return l.forEach ( fungsi (e) {var t = -1 === ['kiri', 'atas']. indexOf (e)? 'sekunder': 'primer'; f = fe ({}, f, m [t] ( e))}), e.offsets.popper = f, e}, prioritas: ['kiri', 'kanan', 'atas', 'bawah'], bantalan: 5, boundariesElement: 'scrollParent'}, keepT Together: {order: 400, diaktifkan:! 0, fn: function (e) {var t = e.offsets, o = t.popper, n = t.reference, i = e.placement.split ('-') [0 ], r = Z, p = -1! == ['top', 'bottom']. indexOf (i), s = p? 'right': 'bottom', d = p? 'left': 'top ', a = p?' width ':' height '; return of [s] <r (n [d]) && (e.offsets.popper [d] = r (n [d]) - o [a] ),o [d]> r (n [s]) && (e.offsets.popper [d] = r (n [s])), e}}, panah: {urutan: 500, diaktifkan:! 0, fn: function (e, o) {var n; if (! K (e.instance.modifiers, 'panah', 'keepTogether')) mengembalikan e; var i = o.element; if ('string' == typeof i) {if (i = e.instance.popper.querySelector (i) ,! i) return e;} lain jika (! e.instance.popper.contains (i)) mengembalikan console.warn ('PERINGATAN: `arrow.element `harus merupakan anak dari elemen poppernya! '), e; var r = e.placement.split (' - ') [0], p = e.offsets, s = p.popper, d = p.reference, a = -1! == ['kiri', 'kanan']. IndexOf (r), l = a? 'Tinggi': 'lebar', f = a? 'Atas': 'Kiri', m = f.toLowerCase (), h = a? 'kiri': 'atas', c = a? 'bawah': 'kanan', u = S (i) [l]; d [c] -u <s [m] && ( e.offsets.popper [m] - = s [m] - (d [c] -u)), d [m] + u> s [c] && (e.offsets.popper [m] + = d [ m] + us [c]), e.offsets.popper = g (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, w = t (e.instance.popper), y = parseFloat (w ['margin' + f], 10) , E = parseFloat (w ['border' + f + 'Width'], 10), v = be.offsets.popper [m] -yE; return v = ee (Q (s [l] -u, v), 0), e.arrowElement = i, e.offsets.arrow = (n = {}, le (n, m, $ (v)), le (n, h, ''), n), e}, elemen : '[x-panah]'}, flip: {urutan: 600, diaktifkan:! 0, fn: function (e, t) {if (W (e.instance.modifiers, 'inner')) mengembalikan e; jika (e.flipped && e.placement === e.originalPlacement) mengembalikan e; var o = v (e.instance.popper, e.instance.reference, t.padding, t.boundariesElement, e.positionFixed), n = e. penempatan.split ('-') [0], i = T (n), r = e.placement.split ('-') [1] || '', p = []; switch (t.behavior) {case ge.FLIP: p = [n, i]; break; case ge.CLOCKWISE: p = G (n); break; case ge.COUNTERCLOCKWISE: p = G (n,! 0); break; default: p = t.behavior;} return p.forEach (fungsi (s, d) {if (n! == s || p.panjang === d + 1) mengembalikan e; n = e.placement.split ('-') [0], i = T (n); var a = e.offsets.popper, l = e.offsets.reference , f = Z, m = 'kiri' === n && f (a.right)> f (l.left) || 'right' === n && f (a.left) <f (l.right) || ' atas '=== n && f (a.bottom)> f (l.top) ||' bawah '=== n && f (a.top) <f (l.bottom), h = f (a.left) <f (o.left), c = f (a.right)> f (o.right), g = f (a.top) <f (o.top), u = f (a.bottom)> f (o .bottom), b = 'kiri' === n && h || 'kanan' === n && c || 'top' === n && g || 'bawah' === n && u, w = -1! == [' top ',' bottom ']. indexOf (n), y = !! t.flipVariations && (w &&' start '=== r && h || w &&' end '=== r && c ||! w &&' start '=== r && g ||! w && 'end' === r && u); (m || b || y) && (e.flipped =! 0, (m || b) && (n = p [d + 1]), y && (r = z (r)), e.placement = n + (r? '-' + r: ''), e.offsets.popper = fe ({} , e.offsets.popper, D (e.instance.popper, e.offsets.reference, e.placement)), e = P (e.instance.modifiers, e, 'flip'))}), e}, perilaku: 'flip', padding: 5, boundariesElement: 'viewport'}, bagian dalam: {urutan: 700, diaktifkan:! 1, fn: fungsi (e) {var t = e.placement, o = t.split (' - ') [0], n = e.offsets, i = n.popper, r = n.referensi, p = -1! == [' kiri ',' kanan ']. IndexOf (o), s = - 1 === ['top', 'left']. IndexOf (o); return i [p? 'Left': 'top'] = r [o] - (s? I [p? 'Width': ' height ']: 0), e.placement = T (t), e.offsets.popper = g (i), e}}, sembunyikan: {order: 800, diaktifkan:! 0, fn: function (e) { if (! K (e.instance.modifiers, 'hide', 'preventOverflow')) mengembalikan e; var t = e.offsets.reference, o = C (e.instance.modifiers, fungsi (e) {return 'preventOverflow '=== e.name}) .batas; if (t.bottom <o.top || t.left> o.right || t.top> o.bottom || t.right <o.left) {if (! 0 === e.hide) mengembalikan e; e.hide =! 0, e.attributes ['x-out-of-boundaries'] = ''} lain {jika (! 1 === e .hide) return e; e.hide =! 1, e.attributes ['x-out-of-boundaries'] =! 1} return e}}, computeStyle: {order: 850, diaktifkan:! 0, fn: fungsi (e, t) {var = tx, n = ty, i = e.offsets.popper, r = C (e.instance.modifiers, fungsi (e) {return'applyStyle '=== e.name} ) .gpuAcceleration; void 0! == r && console.warn (opsi 'PERINGATAN: `gpuAcceleration` dipindahkan ke pengubah` computeStyle` dan tidak akan didukung di versi Popper.js!'); var s, d, a = void 0 === r? T.gpuAcceleration: r, l = p (e.instance.popper), f = u (l), m = {posisi: i.position}, h = q (e, 2> window. devicePixelRatio ||! me), c = 'bottom' === o? 'top': 'bottom', g = 'right '=== n?' left ':' right ', b = H (' transform '); if (d =' bottom '== c?' HTML '=== l.nodeName? -l.clientHeight + h.bottom: -f.height + h.bottom: h.top, s = 'right' == g? 'HTML' === l.nodeName? -l.clientWidth + h.right: -f.width + h.right: h.left, a && b) m [b] = 'translate3d (' + s + 'px,' + d + 'px, 0)', m [c] = 0, m [g] = 0, m. willChange = 'transform'; selain itu {var w = 'bottom' == c? -1: 1, y = 'benar' == g? -1: 1; m [c] = d * w, m [g] = s * y, m.willChange = c + ',' + g} var E = {"x-placement": e.placement}; mengembalikan e.attributes = fe ({}, E, e.attributes), e. gaya = fe ({}, m, e.styles), e.arrowStyles = fe ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAkselerasi:! 0, x: 'bawah', y: 'benar'}, applyStyle: {order: 900, diaktifkan:! 0, fn: function (e) {return j (e.instance.popper, e.styles), V (e.instance.popper, e.attributes) , e.arrowElement && Object.keys (e.arrowStyles). length && j (e.arrowElement, e.arrowStyles), e}, onLoad: fungsi (e, t, o, n, i) {var r = L (i, t, e, o .positionFixed), p = O (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); kembalikan t.setAttribute ('x-penempatan', p), j (t, {position: o.positionFixed? 'fixed': 'absolute'}), o}, gpuAcceleration: void 0}}}, ue}); // # sourceMappingURL = popper.min.js.map